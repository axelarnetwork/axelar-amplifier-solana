/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU128Decoder,
  getU128Encoder,
  getU16Decoder,
  getU16Encoder,
  getU64Decoder,
  getU64Encoder,
  type Codec,
  type Decoder,
  type Encoder,
  type ReadonlyUint8Array,
} from 'gill';
import {
  getPublicKeyDecoder,
  getPublicKeyEncoder,
  type PublicKey,
  type PublicKeyArgs,
} from '.';

export type VerifierSetLeaf = {
  /** The nonce value from the associated `VerifierSet`. */
  nonce: bigint;
  /** The quorum value from the associated `VerifierSet`. */
  quorum: bigint;
  /** The public key of the verifier. */
  signerPubkey: PublicKey;
  /**
   * The weight assigned to the verifier, representing their voting power or
   * authority.
   */
  signerWeight: bigint;
  /** The position of this leaf within the Merkle tree. */
  position: number;
  /**
   * The total number of leaves in the Merkle tree, representing the size of
   * the verifier set.
   */
  setSize: number;
  /**
   * A domain separator used to ensure the uniqueness of hashes across
   * different contexts.
   */
  domainSeparator: ReadonlyUint8Array;
};

export type VerifierSetLeafArgs = {
  /** The nonce value from the associated `VerifierSet`. */
  nonce: number | bigint;
  /** The quorum value from the associated `VerifierSet`. */
  quorum: number | bigint;
  /** The public key of the verifier. */
  signerPubkey: PublicKeyArgs;
  /**
   * The weight assigned to the verifier, representing their voting power or
   * authority.
   */
  signerWeight: number | bigint;
  /** The position of this leaf within the Merkle tree. */
  position: number;
  /**
   * The total number of leaves in the Merkle tree, representing the size of
   * the verifier set.
   */
  setSize: number;
  /**
   * A domain separator used to ensure the uniqueness of hashes across
   * different contexts.
   */
  domainSeparator: ReadonlyUint8Array;
};

export function getVerifierSetLeafEncoder(): Encoder<VerifierSetLeafArgs> {
  return getStructEncoder([
    ['nonce', getU64Encoder()],
    ['quorum', getU128Encoder()],
    ['signerPubkey', getPublicKeyEncoder()],
    ['signerWeight', getU128Encoder()],
    ['position', getU16Encoder()],
    ['setSize', getU16Encoder()],
    ['domainSeparator', fixEncoderSize(getBytesEncoder(), 32)],
  ]);
}

export function getVerifierSetLeafDecoder(): Decoder<VerifierSetLeaf> {
  return getStructDecoder([
    ['nonce', getU64Decoder()],
    ['quorum', getU128Decoder()],
    ['signerPubkey', getPublicKeyDecoder()],
    ['signerWeight', getU128Decoder()],
    ['position', getU16Decoder()],
    ['setSize', getU16Decoder()],
    ['domainSeparator', fixDecoderSize(getBytesDecoder(), 32)],
  ]);
}

export function getVerifierSetLeafCodec(): Codec<
  VerifierSetLeafArgs,
  VerifierSetLeaf
> {
  return combineCodec(getVerifierSetLeafEncoder(), getVerifierSetLeafDecoder());
}
