/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type ReadonlyUint8Array,
} from 'gill';

/**
 * Custom u128 type with 8-byte alignment instead of the default 16-byte alignment.
 *
 * This type is required for zero-copy accounts in Anchor. The standard `u128` type
 * has 16-byte alignment, which creates a misalignment issue with Anchor's 8-byte
 * discriminator:
 * - Account discriminator occupies bytes 0-7 (8 bytes)
 * - Account data starts at byte 8
 * - With 16-byte alignment, the data at byte 8 is not properly aligned for `u128`
 * - This causes `bytemuck::from_bytes` to fail during deserialization
 *
 * By using `[u8; 16]` as the underlying representation, we achieve 8-byte alignment
 * while maintaining the same byte layout as `u128` (little-endian). This makes the
 * type compatible with both Anchor's zero-copy deserialization and existing account
 * data from the previous program version that used `u128`.
 *
 * The byte representation is identical to `u128`, ensuring backwards compatibility.
 */
export type U128 = { bytes: ReadonlyUint8Array };

export type U128Args = U128;

export function getU128Encoder(): FixedSizeEncoder<U128Args> {
  return getStructEncoder([['bytes', fixEncoderSize(getBytesEncoder(), 16)]]);
}

export function getU128Decoder(): FixedSizeDecoder<U128> {
  return getStructDecoder([['bytes', fixDecoderSize(getBytesDecoder(), 16)]]);
}

export function getU128Codec(): FixedSizeCodec<U128Args, U128> {
  return combineCodec(getU128Encoder(), getU128Decoder());
}
