/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from 'gill';
import {
  type ParsedEmitMemoInstruction,
  type ParsedExecuteInstruction,
  type ParsedInitInstruction,
  type ParsedSendMemoInstruction,
} from '../instructions';

export const MEMO_PROGRAM_ADDRESS =
  '8VRxuTLvEWsUcGsA299QQdUPaFuYkV6qkHDC5gtqt3Zc' as Address<'8VRxuTLvEWsUcGsA299QQdUPaFuYkV6qkHDC5gtqt3Zc'>;

export enum MemoAccount {
  Counter,
  GatewayConfig,
  IncomingMessage,
}

export function identifyMemoAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): MemoAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([255, 176, 4, 245, 188, 253, 124, 25])
      ),
      0
    )
  ) {
    return MemoAccount.Counter;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([91, 247, 66, 27, 24, 1, 48, 176])
      ),
      0
    )
  ) {
    return MemoAccount.GatewayConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([30, 144, 125, 111, 211, 223, 91, 170])
      ),
      0
    )
  ) {
    return MemoAccount.IncomingMessage;
  }
  throw new Error(
    'The provided account could not be identified as a memo account.'
  );
}

export enum MemoInstruction {
  EmitMemo,
  Execute,
  Init,
  SendMemo,
}

export function identifyMemoInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): MemoInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([157, 222, 212, 21, 59, 139, 46, 222])
      ),
      0
    )
  ) {
    return MemoInstruction.EmitMemo;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([130, 221, 242, 154, 13, 193, 189, 29])
      ),
      0
    )
  ) {
    return MemoInstruction.Execute;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([220, 59, 207, 236, 108, 250, 47, 100])
      ),
      0
    )
  ) {
    return MemoInstruction.Init;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([206, 178, 79, 19, 63, 210, 72, 239])
      ),
      0
    )
  ) {
    return MemoInstruction.SendMemo;
  }
  throw new Error(
    'The provided instruction could not be identified as a memo instruction.'
  );
}

export type ParsedMemoInstruction<
  TProgram extends string = '8VRxuTLvEWsUcGsA299QQdUPaFuYkV6qkHDC5gtqt3Zc',
> =
  | ({
      instructionType: MemoInstruction.EmitMemo;
    } & ParsedEmitMemoInstruction<TProgram>)
  | ({
      instructionType: MemoInstruction.Execute;
    } & ParsedExecuteInstruction<TProgram>)
  | ({
      instructionType: MemoInstruction.Init;
    } & ParsedInitInstruction<TProgram>)
  | ({
      instructionType: MemoInstruction.SendMemo;
    } & ParsedSendMemoInstruction<TProgram>);
