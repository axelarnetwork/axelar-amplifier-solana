/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type AccountMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlyUint8Array,
  type WritableAccount,
} from 'gill';
import { MEMO_PROGRAM_ADDRESS } from '../programs';
import {
  expectSome,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';
import {
  getCrossChainIdDecoder,
  getCrossChainIdEncoder,
  getEncodingSchemeDecoder,
  getEncodingSchemeEncoder,
  type CrossChainId,
  type CrossChainIdArgs,
  type EncodingScheme,
  type EncodingSchemeArgs,
} from '../types';

export const EXECUTE_DISCRIMINATOR = new Uint8Array([
  130, 221, 242, 154, 13, 193, 189, 29,
]);

export function getExecuteDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(EXECUTE_DISCRIMINATOR);
}

export type ExecuteInstruction<
  TProgram extends string = typeof MEMO_PROGRAM_ADDRESS,
  TAccountIncomingMessagePda extends string | AccountMeta<string> = string,
  TAccountSigningPda extends string | AccountMeta<string> = string,
  TAccountGatewayRootPda extends string | AccountMeta<string> = string,
  TAccountEventAuthority extends string | AccountMeta<string> = string,
  TAccountAxelarGatewayProgram extends
    | string
    | AccountMeta<string> = '41ky5cHRCTPEP5c8hnS8Bwco5vnbxe31iKm26rJs3QYd',
  TAccountCounter extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountIncomingMessagePda extends string
        ? WritableAccount<TAccountIncomingMessagePda>
        : TAccountIncomingMessagePda,
      TAccountSigningPda extends string
        ? ReadonlyAccount<TAccountSigningPda>
        : TAccountSigningPda,
      TAccountGatewayRootPda extends string
        ? ReadonlyAccount<TAccountGatewayRootPda>
        : TAccountGatewayRootPda,
      TAccountEventAuthority extends string
        ? ReadonlyAccount<TAccountEventAuthority>
        : TAccountEventAuthority,
      TAccountAxelarGatewayProgram extends string
        ? ReadonlyAccount<TAccountAxelarGatewayProgram>
        : TAccountAxelarGatewayProgram,
      TAccountCounter extends string
        ? WritableAccount<TAccountCounter>
        : TAccountCounter,
      ...TRemainingAccounts,
    ]
  >;

export type ExecuteInstructionData = {
  discriminator: ReadonlyUint8Array;
  commandId: ReadonlyUint8Array;
  /** The cross-chain identifier of the message */
  ccId: CrossChainId;
  /** The source address from which the message originates. */
  sourceAddress: string;
  /** The destination blockchain where the message is intended to be sent. */
  destinationChain: string;
  /** The destination address on the target blockchain. */
  destinationAddress: string;
  /** A 32-byte hash of the message payload, ensuring data integrity. */
  payloadHash: ReadonlyUint8Array;
  payload: ReadonlyUint8Array;
  encodingScheme: EncodingScheme;
};

export type ExecuteInstructionDataArgs = {
  commandId: ReadonlyUint8Array;
  /** The cross-chain identifier of the message */
  ccId: CrossChainIdArgs;
  /** The source address from which the message originates. */
  sourceAddress: string;
  /** The destination blockchain where the message is intended to be sent. */
  destinationChain: string;
  /** The destination address on the target blockchain. */
  destinationAddress: string;
  /** A 32-byte hash of the message payload, ensuring data integrity. */
  payloadHash: ReadonlyUint8Array;
  payload: ReadonlyUint8Array;
  encodingScheme: EncodingSchemeArgs;
};

export function getExecuteInstructionDataEncoder(): Encoder<ExecuteInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['commandId', fixEncoderSize(getBytesEncoder(), 32)],
      ['ccId', getCrossChainIdEncoder()],
      [
        'sourceAddress',
        addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
      ],
      [
        'destinationChain',
        addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
      ],
      [
        'destinationAddress',
        addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),
      ],
      ['payloadHash', fixEncoderSize(getBytesEncoder(), 32)],
      ['payload', addEncoderSizePrefix(getBytesEncoder(), getU32Encoder())],
      ['encodingScheme', getEncodingSchemeEncoder()],
    ]),
    (value) => ({ ...value, discriminator: EXECUTE_DISCRIMINATOR })
  );
}

export function getExecuteInstructionDataDecoder(): Decoder<ExecuteInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['commandId', fixDecoderSize(getBytesDecoder(), 32)],
    ['ccId', getCrossChainIdDecoder()],
    ['sourceAddress', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
    [
      'destinationChain',
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),
    ],
    [
      'destinationAddress',
      addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),
    ],
    ['payloadHash', fixDecoderSize(getBytesDecoder(), 32)],
    ['payload', addDecoderSizePrefix(getBytesDecoder(), getU32Decoder())],
    ['encodingScheme', getEncodingSchemeDecoder()],
  ]);
}

export function getExecuteInstructionDataCodec(): Codec<
  ExecuteInstructionDataArgs,
  ExecuteInstructionData
> {
  return combineCodec(
    getExecuteInstructionDataEncoder(),
    getExecuteInstructionDataDecoder()
  );
}

export type ExecuteAsyncInput<
  TAccountIncomingMessagePda extends string = string,
  TAccountSigningPda extends string = string,
  TAccountGatewayRootPda extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountAxelarGatewayProgram extends string = string,
  TAccountCounter extends string = string,
> = {
  incomingMessagePda?: Address<TAccountIncomingMessagePda>;
  signingPda?: Address<TAccountSigningPda>;
  gatewayRootPda?: Address<TAccountGatewayRootPda>;
  eventAuthority?: Address<TAccountEventAuthority>;
  axelarGatewayProgram?: Address<TAccountAxelarGatewayProgram>;
  counter?: Address<TAccountCounter>;
  commandId: ExecuteInstructionDataArgs['commandId'];
  ccId: ExecuteInstructionDataArgs['ccId'];
  sourceAddress: ExecuteInstructionDataArgs['sourceAddress'];
  destinationChain: ExecuteInstructionDataArgs['destinationChain'];
  destinationAddress: ExecuteInstructionDataArgs['destinationAddress'];
  payloadHash: ExecuteInstructionDataArgs['payloadHash'];
  payload: ExecuteInstructionDataArgs['payload'];
  encodingScheme: ExecuteInstructionDataArgs['encodingScheme'];
};

export async function getExecuteInstructionAsync<
  TAccountIncomingMessagePda extends string,
  TAccountSigningPda extends string,
  TAccountGatewayRootPda extends string,
  TAccountEventAuthority extends string,
  TAccountAxelarGatewayProgram extends string,
  TAccountCounter extends string,
  TProgramAddress extends Address = typeof MEMO_PROGRAM_ADDRESS,
>(
  input: ExecuteAsyncInput<
    TAccountIncomingMessagePda,
    TAccountSigningPda,
    TAccountGatewayRootPda,
    TAccountEventAuthority,
    TAccountAxelarGatewayProgram,
    TAccountCounter
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  ExecuteInstruction<
    TProgramAddress,
    TAccountIncomingMessagePda,
    TAccountSigningPda,
    TAccountGatewayRootPda,
    TAccountEventAuthority,
    TAccountAxelarGatewayProgram,
    TAccountCounter
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? MEMO_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    incomingMessagePda: {
      value: input.incomingMessagePda ?? null,
      isWritable: true,
    },
    signingPda: { value: input.signingPda ?? null, isWritable: false },
    gatewayRootPda: { value: input.gatewayRootPda ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    axelarGatewayProgram: {
      value: input.axelarGatewayProgram ?? null,
      isWritable: false,
    },
    counter: { value: input.counter ?? null, isWritable: true },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.incomingMessagePda.value) {
    accounts.incomingMessagePda.value = await getProgramDerivedAddress({
      programAddress:
        '41ky5cHRCTPEP5c8hnS8Bwco5vnbxe31iKm26rJs3QYd' as Address<'41ky5cHRCTPEP5c8hnS8Bwco5vnbxe31iKm26rJs3QYd'>,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            105, 110, 99, 111, 109, 105, 110, 103, 32, 109, 101, 115, 115, 97,
            103, 101,
          ])
        ),
        fixEncoderSize(getBytesEncoder(), 32).encode(
          expectSome(args.commandId)
        ),
      ],
    });
  }
  if (!accounts.signingPda.value) {
    accounts.signingPda.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            103, 116, 119, 45, 118, 97, 108, 105, 100, 97, 116, 101, 45, 109,
            115, 103,
          ])
        ),
        fixEncoderSize(getBytesEncoder(), 32).encode(
          expectSome(args.commandId)
        ),
      ],
    });
  }
  if (!accounts.gatewayRootPda.value) {
    accounts.gatewayRootPda.value = await getProgramDerivedAddress({
      programAddress:
        '41ky5cHRCTPEP5c8hnS8Bwco5vnbxe31iKm26rJs3QYd' as Address<'41ky5cHRCTPEP5c8hnS8Bwco5vnbxe31iKm26rJs3QYd'>,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([103, 97, 116, 101, 119, 97, 121])
        ),
      ],
    });
  }
  if (!accounts.eventAuthority.value) {
    accounts.eventAuthority.value = await getProgramDerivedAddress({
      programAddress:
        '41ky5cHRCTPEP5c8hnS8Bwco5vnbxe31iKm26rJs3QYd' as Address<'41ky5cHRCTPEP5c8hnS8Bwco5vnbxe31iKm26rJs3QYd'>,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            95, 95, 101, 118, 101, 110, 116, 95, 97, 117, 116, 104, 111, 114,
            105, 116, 121,
          ])
        ),
      ],
    });
  }
  if (!accounts.axelarGatewayProgram.value) {
    accounts.axelarGatewayProgram.value =
      '41ky5cHRCTPEP5c8hnS8Bwco5vnbxe31iKm26rJs3QYd' as Address<'41ky5cHRCTPEP5c8hnS8Bwco5vnbxe31iKm26rJs3QYd'>;
  }
  if (!accounts.counter.value) {
    accounts.counter.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([99, 111, 117, 110, 116, 101, 114])
        ),
      ],
    });
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.incomingMessagePda),
      getAccountMeta(accounts.signingPda),
      getAccountMeta(accounts.gatewayRootPda),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.axelarGatewayProgram),
      getAccountMeta(accounts.counter),
    ],
    data: getExecuteInstructionDataEncoder().encode(
      args as ExecuteInstructionDataArgs
    ),
    programAddress,
  } as ExecuteInstruction<
    TProgramAddress,
    TAccountIncomingMessagePda,
    TAccountSigningPda,
    TAccountGatewayRootPda,
    TAccountEventAuthority,
    TAccountAxelarGatewayProgram,
    TAccountCounter
  >);
}

export type ExecuteInput<
  TAccountIncomingMessagePda extends string = string,
  TAccountSigningPda extends string = string,
  TAccountGatewayRootPda extends string = string,
  TAccountEventAuthority extends string = string,
  TAccountAxelarGatewayProgram extends string = string,
  TAccountCounter extends string = string,
> = {
  incomingMessagePda: Address<TAccountIncomingMessagePda>;
  signingPda: Address<TAccountSigningPda>;
  gatewayRootPda: Address<TAccountGatewayRootPda>;
  eventAuthority: Address<TAccountEventAuthority>;
  axelarGatewayProgram?: Address<TAccountAxelarGatewayProgram>;
  counter: Address<TAccountCounter>;
  commandId: ExecuteInstructionDataArgs['commandId'];
  ccId: ExecuteInstructionDataArgs['ccId'];
  sourceAddress: ExecuteInstructionDataArgs['sourceAddress'];
  destinationChain: ExecuteInstructionDataArgs['destinationChain'];
  destinationAddress: ExecuteInstructionDataArgs['destinationAddress'];
  payloadHash: ExecuteInstructionDataArgs['payloadHash'];
  payload: ExecuteInstructionDataArgs['payload'];
  encodingScheme: ExecuteInstructionDataArgs['encodingScheme'];
};

export function getExecuteInstruction<
  TAccountIncomingMessagePda extends string,
  TAccountSigningPda extends string,
  TAccountGatewayRootPda extends string,
  TAccountEventAuthority extends string,
  TAccountAxelarGatewayProgram extends string,
  TAccountCounter extends string,
  TProgramAddress extends Address = typeof MEMO_PROGRAM_ADDRESS,
>(
  input: ExecuteInput<
    TAccountIncomingMessagePda,
    TAccountSigningPda,
    TAccountGatewayRootPda,
    TAccountEventAuthority,
    TAccountAxelarGatewayProgram,
    TAccountCounter
  >,
  config?: { programAddress?: TProgramAddress }
): ExecuteInstruction<
  TProgramAddress,
  TAccountIncomingMessagePda,
  TAccountSigningPda,
  TAccountGatewayRootPda,
  TAccountEventAuthority,
  TAccountAxelarGatewayProgram,
  TAccountCounter
> {
  // Program address.
  const programAddress = config?.programAddress ?? MEMO_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    incomingMessagePda: {
      value: input.incomingMessagePda ?? null,
      isWritable: true,
    },
    signingPda: { value: input.signingPda ?? null, isWritable: false },
    gatewayRootPda: { value: input.gatewayRootPda ?? null, isWritable: false },
    eventAuthority: { value: input.eventAuthority ?? null, isWritable: false },
    axelarGatewayProgram: {
      value: input.axelarGatewayProgram ?? null,
      isWritable: false,
    },
    counter: { value: input.counter ?? null, isWritable: true },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.axelarGatewayProgram.value) {
    accounts.axelarGatewayProgram.value =
      '41ky5cHRCTPEP5c8hnS8Bwco5vnbxe31iKm26rJs3QYd' as Address<'41ky5cHRCTPEP5c8hnS8Bwco5vnbxe31iKm26rJs3QYd'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.incomingMessagePda),
      getAccountMeta(accounts.signingPda),
      getAccountMeta(accounts.gatewayRootPda),
      getAccountMeta(accounts.eventAuthority),
      getAccountMeta(accounts.axelarGatewayProgram),
      getAccountMeta(accounts.counter),
    ],
    data: getExecuteInstructionDataEncoder().encode(
      args as ExecuteInstructionDataArgs
    ),
    programAddress,
  } as ExecuteInstruction<
    TProgramAddress,
    TAccountIncomingMessagePda,
    TAccountSigningPda,
    TAccountGatewayRootPda,
    TAccountEventAuthority,
    TAccountAxelarGatewayProgram,
    TAccountCounter
  >);
}

export type ParsedExecuteInstruction<
  TProgram extends string = typeof MEMO_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    incomingMessagePda: TAccountMetas[0];
    signingPda: TAccountMetas[1];
    gatewayRootPda: TAccountMetas[2];
    eventAuthority: TAccountMetas[3];
    axelarGatewayProgram: TAccountMetas[4];
    counter: TAccountMetas[5];
  };
  data: ExecuteInstructionData;
};

export function parseExecuteInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedExecuteInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 6) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      incomingMessagePda: getNextAccount(),
      signingPda: getNextAccount(),
      gatewayRootPda: getNextAccount(),
      eventAuthority: getNextAccount(),
      axelarGatewayProgram: getNextAccount(),
      counter: getNextAccount(),
    },
    data: getExecuteInstructionDataDecoder().decode(instruction.data),
  };
}
