name: "Upload Program sBPFs to Cloudflare R2"

on:
  workflow_call:
    inputs:
      package-name:
        description: "The package name to use (ex: solana-axelar-gateway)"
        type: string
        required: true
        default: ""
      package-version:
        description: "The package version to use (ex: 0.1.2)"
        type: string
        required: true
        default: ""
      package-git-tag:
        description: "the release tag name (ex: solana-axelar-gateway-v1.1.0)"
        type: string
        required: true
        default: ""
      artifact-name:
        description: "Name of the artifact containing the builds"
        type: string
        required: true
      artifact-path:
        description: "Path of the artifact containing the builds"
        type: string
        required: true
      cf-bucket-name:
        description: "The CF bucket name to use"
        required: true
        type: string
      cf-config-bucket-root-key:
        description: "The root key to be used for accessing the configs. (ex: `test-root-key` puts releases in `test-root-key/*`)"
        required: true
        type: string
      github-release:
        description: "Whether to upload as a github release"
        type: boolean
        default: true

    secrets:
      github-token:
        description: "The github token to use to do the tag updates"
        required: true
      cf-endpoint-url:
        description: "The endpoint URL of the CF bucket"
        required: true
      cf-bucket-access-key-id:
        description: "The CF bucket access key id"
        required: true
      cf-bucket-secret-access-key:
        description: "The CF bucket secret access key"
        required: true

jobs:
  upload:
    name: Upload ${{ inputs.package-git-tag }}
    runs-on: blacksmith-2vcpu-ubuntu-2204
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.artifact-name }}
          path: ${{ inputs.artifact-path }}

      - name: Prepare cross-steps variables
        run: |
          export PACKAGE_NAME='${{ inputs.package-name }}'
          export PACKAGE_VERSION=${{ inputs.github-release && format('v{0}', inputs.package-version) || inputs.package-version }}

          export BASE_ARTIFACTS_DIR='${{ inputs.artifact-path }}'

          export ARCHIVES_OUTPUT_DIR="${{ github.workspace }}/build/archives"

          # Convert package name from kebab-case to snake_case for matching .so filename
          export PROGRAM_SO_NAME=$(echo "${PACKAGE_NAME}" | tr '-' '_').so

          # Ensures that this dir is created
          mkdir -p ${ARCHIVES_OUTPUT_DIR}

          # ex: solana-axelar-gateway
          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV

          # ex: v0.1.0
          echo "PACKAGE_VERSION=${PACKAGE_VERSION}" >> $GITHUB_ENV

          # ex: ./target/deploy
          echo "BASE_ARTIFACTS_DIR=${BASE_ARTIFACTS_DIR}" >> $GITHUB_ENV

          echo "ARCHIVES_OUTPUT_DIR=${ARCHIVES_OUTPUT_DIR}" >> $GITHUB_ENV

          # ex: solana_axelar_gateway.so
          echo "PROGRAM_SO_NAME=${PROGRAM_SO_NAME}" >> $GITHUB_ENV

      - name: Prepare per-network artifacts, archives, and GitHub release files
        run: |
          NETWORKS="devnet-amplifier stagenet testnet mainnet"
          GITHUB_RELEASE_FILES=""

          for network in $NETWORKS; do
            echo "=========================================="
            echo "Processing network: $network"
            echo "=========================================="

            SO_FILE="${{ env.BASE_ARTIFACTS_DIR }}/${network}/${{ env.PROGRAM_SO_NAME }}"

            # Verify the program binary exists
            if [ ! -f "$SO_FILE" ]; then
              echo "Error: Program binary '$SO_FILE' not found"
              exit 1
            fi

            # --- Archives ---
            ARTIFACT_NAME="axelar-amplifier-solana-${{ env.PACKAGE_NAME }}-${{ env.PACKAGE_VERSION }}-${network}"
            ZIP_ARCHIVE_FILE="${{ env.ARCHIVES_OUTPUT_DIR }}/${ARTIFACT_NAME}.zip"
            TAR_ARCHIVE_FILE="${{ env.ARCHIVES_OUTPUT_DIR }}/${ARTIFACT_NAME}.tar.gz"

            # Create a temporary versioned dir for archive structure
            VERSIONED_DIR="${{ github.workspace }}/build/versioned-${network}/${ARTIFACT_NAME}"
            mkdir -p "${VERSIONED_DIR}"
            cp "$SO_FILE" "${VERSIONED_DIR}/${{ env.PROGRAM_SO_NAME }}"

            # Create archives
            cd "${VERSIONED_DIR}"
            find "." -type f -name "${{ env.PROGRAM_SO_NAME }}" -maxdepth 1 -print | zip "${ZIP_ARCHIVE_FILE}" -@
            find "." -type f -name "${{ env.PROGRAM_SO_NAME }}" -maxdepth 1 -print | tar -czvf "${TAR_ARCHIVE_FILE}" -T -
            cd "${{ github.workspace }}"

            # Verify archives were created successfully and are not empty
            for archive in "${ZIP_ARCHIVE_FILE}" "${TAR_ARCHIVE_FILE}"; do
              if [ ! -f "$archive" ] || [ ! -s "$archive" ]; then
                echo "Error: Archive '$archive' is missing or empty"
                exit 1
              fi
            done

            # Generate SHA-256 Checksums
            for file in "${TAR_ARCHIVE_FILE}" "${ZIP_ARCHIVE_FILE}"; do
              sha256sum "$file" > "$file.sha256"
            done

            # --- GitHub Release files ---
            # Copy .so with network suffix for GitHub release
            SO_BASENAME=$(basename "${{ env.PROGRAM_SO_NAME }}" .so)
            RELEASE_SO_FILE="${{ env.ARCHIVES_OUTPUT_DIR }}/${SO_BASENAME}-${network}.so"
            cp "$SO_FILE" "$RELEASE_SO_FILE"

            # Collect all files for GitHub release
            GITHUB_RELEASE_FILES="${GITHUB_RELEASE_FILES}${TAR_ARCHIVE_FILE}
          ${TAR_ARCHIVE_FILE}.sha256
          ${ZIP_ARCHIVE_FILE}
          ${ZIP_ARCHIVE_FILE}.sha256
          ${RELEASE_SO_FILE}
          "
          done

          echo "GITHUB_RELEASE_FILES<<EOF" >> $GITHUB_ENV
          echo "$GITHUB_RELEASE_FILES" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      # Publishing program binaries to `R2`
      - name: Configure CF credentials
        run: |
          cd $HOME; mkdir ~/.aws; touch ~/.aws/credentials; touch ~/.aws/config
          echo "[default]
          aws_access_key_id = ${{ secrets.cf-bucket-access-key-id }}
          aws_secret_access_key = ${{ secrets.cf-bucket-secret-access-key }}" > ~/.aws/credentials
          echo "[default]
          region=auto
          output=json" > ~/.aws/config

      - name: Publish files to CF R2
        env:
          S3_BUCKET_NAME: ${{ inputs.cf-bucket-name }}
          ENDPOINT_URL: ${{ secrets.cf-endpoint-url }}
          CF_BUCKET_ROOT_KEY: ${{ inputs.cf-config-bucket-root-key }}
        run: |
          NETWORKS="devnet-amplifier stagenet testnet mainnet"

          for network in $NETWORKS; do
            echo "=========================================="
            echo "Uploading to R2 for network: $network"
            echo "=========================================="

            # R2 path: ROOT_KEY/PACKAGE_NAME/VERSION/NETWORK/programs/so_file.so
            CF_PROGRAMS_BUCKET_ROOT_KEY="${CF_BUCKET_ROOT_KEY}/${{ env.PACKAGE_NAME }}/${{ env.PACKAGE_VERSION }}/${network}/programs"

            SO_FILE="${{ env.BASE_ARTIFACTS_DIR }}/${network}/${{ env.PROGRAM_SO_NAME }}"

            echo "Uploading program file: ${SO_FILE}"
            echo "Uploading to key: ${CF_PROGRAMS_BUCKET_ROOT_KEY}/${{ env.PROGRAM_SO_NAME }}"
            aws s3api put-object --bucket $S3_BUCKET_NAME --key "${CF_PROGRAMS_BUCKET_ROOT_KEY}/${{ env.PROGRAM_SO_NAME }}" --body "$SO_FILE" --acl public-read --endpoint-url $ENDPOINT_URL

            # Upload per-network archives to R2
            CF_ARCHIVES_BUCKET_ROOT_KEY="${CF_BUCKET_ROOT_KEY}/${{ env.PACKAGE_NAME }}/${{ env.PACKAGE_VERSION }}/${network}/archives"

            ARTIFACT_NAME="axelar-amplifier-solana-${{ env.PACKAGE_NAME }}-${{ env.PACKAGE_VERSION }}-${network}"
            TAR_ARCHIVE_FILE="${{ env.ARCHIVES_OUTPUT_DIR }}/${ARTIFACT_NAME}.tar.gz"
            ZIP_ARCHIVE_FILE="${{ env.ARCHIVES_OUTPUT_DIR }}/${ARTIFACT_NAME}.zip"

            for file in "$TAR_ARCHIVE_FILE" "$ZIP_ARCHIVE_FILE"; do
              FILE_NAME=$(basename "${file}")
              aws s3api put-object --bucket $S3_BUCKET_NAME --key "$CF_ARCHIVES_BUCKET_ROOT_KEY/$FILE_NAME" --body "$file" --acl public-read --endpoint-url $ENDPOINT_URL
              aws s3api put-object --bucket $S3_BUCKET_NAME --key "$CF_ARCHIVES_BUCKET_ROOT_KEY/$FILE_NAME.sha256" --body "$file.sha256" --acl public-read --endpoint-url $ENDPOINT_URL
            done
          done

      # Update the existing release and upload the program binaries, zip and tar archives to the specific tag
      # https://github.com/orgs/community/discussions/26263#discussioncomment-3251069
      - name: Update the GitHub Release
        uses: softprops/action-gh-release@c062e08bd532815e2082a85e87e3ef29c3e6d191 # v2.0.8
        if: inputs.github-release
        with:
          tag_name: ${{ inputs.package-git-tag }} # This uses the tag from the push
          files: ${{ env.GITHUB_RELEASE_FILES }}
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
